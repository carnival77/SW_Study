# 주기억장치 할당 기법

---

- [주기억장치 할당 기법](#주기억장치-할당-기법)
  - [연속 할당 기법(contiguous allocation)](#연속-할당-기법contiguous-allocation)
    - [단일 분할 할당 기법](#단일-분할-할당-기법)
    - [다중 분할 할당 기법](#다중-분할-할당-기법)
      - [고정 분할 할당 기법(=정적 할당 기법)](#고정-분할-할당-기법정적-할당-기법)
        - [단편화 (Fragmentation)](#단편화-fragmentation)
        - [메모리 압축(memory compaction)](#메모리-압축memory-compaction)
      - [가변 분할 할당 기법(=동적 할당 기법)](#가변-분할-할당-기법동적-할당-기법)
  - [분산 할당 기법 (= 비연속 메모리 할당, non-contigous allocation)](#분산-할당-기법--비연속-메모리-할당-non-contigous-allocation)


---

## 연속 할당 기법(contiguous allocation)

>  멀티 프로세스 환경에서 여러 프로세스를 메모리에 연속적으로 로드하는 방법

### 단일 분할 할당 기법

>  주기억장치를 운영체제 영역과 사용자 영역으로 나누어 한 순간에는 오직 한 명의 사용자만이 주기억장치의 사용자 영역을 사용

![image](https://github.com/user-attachments/assets/d61c6820-c43d-4a11-91b7-80f35fa507e6)

- 운영체제를 보호하고, 프로그램이 사용자 영역만을 사용하기 위해 운영체제 영역과 사용자 영역을 구분하는 **경계 레지스터**가 사용

  - **경계 레지스터** : 사용자 영역에 있는 사용자 프로그램이 운영체제 영역에 접근하지 못하도록 보호하는 레지스터. 사용자 영역이 시작되는 주소를 기억

- 단점 : 프로그램의 크기가 작을수록 사용자 영역 낭비

- 종류

  - **오버레이 기법**
    - 주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법

    - ![image](https://github.com/user-attachments/assets/27b288a1-1211-4855-ab83-1133ecfe312d)

    - 하나의 프로그램을 여러 개의 조각으로 분할 한 후 필요한 조각을 차례로 주기억장치에 적재한다.

    - 주기억장치의 공간이 부족하면 주기억장치에 적재된 프로그램 조각 중 불필요한 조각이 위치한 장소에 새로운 프로그램의 조각을 덮어씌워 적재한다.

  - **스와핑** 기법
    - 하나의 프로그램 전체를 주기억장치에 할당하여 사용하다 필요에 따라 다른 프로그램과 교체
    - ![image](https://github.com/user-attachments/assets/0dcfa2eb-c2a0-449d-a751-292fd9349977)
    - 큰 디스크 전송시간이 필요하기 때문에 현재에는 메모리 공간이 부족할때 Swapping 이 시작된다.

      - 문맥 교환으로 인한 오버헤드가 발생할 수 있고 속도가 느려지지만, 메모리 공간 확보에는 효율적

        - swap-out : 프로세스를 메모리에서 쫒아내 스왑 영역에 저장

        - swap-in : 스왑 영역에서 다시 주 기억장치(RAM)으로 불러오는 과정

### 다중 분할 할당 기법

#### 고정 분할 할당 기법(=정적 할당 기법)

>  메모리 영역을 고정된 크기로 분할한 뒤 각 영역에 프로세스를 할당

- 분할된 영역의 크기는 서로 다를 수 있으며, 분할된 크기는 고정된다.
- 프로그램을 실행하려면 프로그램 전체가 주기억장치에 위치해야한다.
- 프로그램이 분할된 영역보다 커서 영역 안에 들어갈 수 없는 경우가 발생할 수 있다.

![image](https://github.com/user-attachments/assets/aa612442-e368-4ff3-a3c5-6c6ba0aeb526)

-   장점 : 관리가 수월
-   단점 : **단편화**가 발생할 수 있다.

##### 단편화 (Fragmentation)

> 주기억장치의 분할된 영역에 프로그램이나 데이터를 할당할 경우, 분할된 영역이 프로그램이나 데이터보다 작거나 커서 생기는 빈 기억 공간

-   **외부 단편화**: 메모리 공간 중 사용하지 못하게 되는 일부분. **물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산**되어 있을때 발생한다고 볼 수 있다.

![image](https://github.com/user-attachments/assets/31ccbd09-413f-4059-a8a0-19d1bcb538c1)

-   **내부 단편화**: **프로세스가 사용하는 메모리 공간에 포함된 남는 부분**. 예를 들어 메모리 분할 자유 공간이 10KB 있고 Process A 가 7KB 사용하게되면 3KB 라는 차이가 존재하고, 이 현상을 **내부 단편화**라 칭한다.

![image](https://github.com/user-attachments/assets/cb545212-843a-4395-8014-dcfbdc210689)

##### 메모리 압축(memory compaction)

> 외부 단편화를 해소하기 위해 프로세스가 사용하는 메모리 공간들을 재배치하여 흩어져 있는 가용 메모리 공간을 하나로 합치는 방법론

하지만 메모리 압축의 재배치로 인해 CPU 처리 시간이 증가하여 효율이 감소한다.

![image](https://github.com/user-attachments/assets/62412462-eb8e-40a3-932f-6dfc0f7798a6)

#### 가변 분할 할당 기법(=동적 할당 기법)

- 할당할 프로세스의 크기에 따라 메모리 공간을 분할
- ![image](https://github.com/user-attachments/assets/bb0dbb6d-3e16-4c4d-abb9-b9bb0aa6564f)
- 메모리 할당 알고리즘을 이용해 가용 메모리 공간에서 프로세스가 로드될 수 있는 메모리 공간을 탐색
  - 메모리 할당 알고리즘 종류(= 메모리 관리 전략 - 배치 정책)
    - 최초 적합
    - 최적 적합
    - 최악 적합


-   장점 : 필요로 하는 크기 만큼의 공간만 할당하면 된다.
-   단점 : 관리가 어렵다. 외부 단편화가 발생할 수 있다.

![image](https://github.com/user-attachments/assets/b76da283-411b-4532-88d8-4572d1dada86)

## 분산 할당 기법 (= 비연속 메모리 할당, non-contigous allocation)

> 프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당

종류

- 페이징 기법
- 세그먼테이션 기법

**Reference**

-   [메모리 관리 2 - 메모리 관리 전략](https://gamedevlog.tistory.com/84)
-   [메모리 관리 전략(1)](https://dduddublog.tistory.com/28)
-   [운영체제 정리 🦖 ch08. 메모리 관리 전략](https://aerocode.net/389)
-   [[운영체제(OS)] 13. 페이징](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-13.-%ED%8E%98%EC%9D%B4%EC%A7%95)
-   [원본 notion 주소](https://chemical-dive-e41.notion.site/8670b6f6f5614effa03413d3cd398826)
-   [][OS][[OS] 주기억장치 할당 기법](https://velog.io/@szlee/OS-%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98-%ED%95%A0%EB%8B%B9-%EA%B8%B0%EB%B2%95)

